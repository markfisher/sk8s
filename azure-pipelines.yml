jobs:
- job: 'unit_linux'
  pool:
    vmImage: 'ubuntu-16.04'
  variables:
    GOBIN:  '$(GOPATH)/bin' # Go binaries path
    GOROOT: '/opt/hostedtoolcache/go/1.12.0/x64' # Go installation path
    GOPATH: '$(system.defaultWorkingDirectory)/gopath' # Go workspace path
    modulePath: '$(build.repository.name)' # Path to the module's code
  steps:
  - template: ci/unit-test-steps.yml
- job: 'unit_mac'
  pool:
    vmImage: 'macos-10.13'
  variables:
    GOBIN:  '$(GOPATH)/bin' # Go binaries path
    GOROOT: '/opt/hostedtoolcache/go/1.12.0/x64' # Go installation path
    GOPATH: '$(system.defaultWorkingDirectory)/gopath' # Go workspace path
    modulePath: '$(build.repository.name)' # Path to the module's code
  steps:
  - template: ci/unit-test-steps.yml
- job: 'unit_windows'
  pool:
    vmImage: 'vs2017-win2016'
  variables:
    GOBIN:  '$(GOPATH)/bin' # Go binaries path
    GOROOT: '/opt/hostedtoolcache/go/1.12.0/x64' # Go installation path
    GOPATH: '$(system.defaultWorkingDirectory)/gopath' # Go workspace path
    modulePath: '$(build.repository.name)' # Path to the module's code
  steps:
  - template: ci/unit-test-steps.yml
- job: stage
  dependsOn:
  # yes, we must specify each unit test jobs
  - 'unit_linux'
  - 'unit_mac'
  - 'unit_windows'
  pool:
    vmImage: ubuntu-16.04
  variables:
    GOBIN:  '$(GOPATH)/bin' # Go binaries path
    GOROOT: '/opt/hostedtoolcache/go/1.12.0/x64' # Go installation path
    GOPATH: '$(system.defaultWorkingDirectory)/gopath' # Go workspace path
    modulePath: '$(build.repository.name)' # Path to the module's code
  steps:
  - task: GoTool@0
    inputs:
      version: 1.12
  - bash: |
      mkdir -p '$(GOBIN)'
      mkdir -p '$(GOPATH)/pkg'
      mkdir -p '$(modulePath)'
      shopt -s extglob
      shopt -s dotglob
      mv !(gopath) '$(modulePath)'
      echo '##vso[task.prependpath]$(GOBIN)'
      echo '##vso[task.prependpath]$(GOROOT)/bin'
    displayName: 'Set up the Go workspace'
  - script: .travis/stage.sh
    displayName: 'Stage riff release artifacts'
- job: fats
  dependsOn: stage
  strategy:
    matrix:
      minikube:
        imageName: ubuntu-16.04
        cluster: minikube
        registry: dockerhub
      gke:
        imageName: ubuntu-16.04
        cluster: gke
        registry: gcr
  pool:
    vmImage: $(imageName)
  variables:
    CLUSTER:  '$(cluster)'
    REGISTRY: '$(registry)'
    CLUSTER_NAME: 'fats-$(Build.BuildId)'
    NAMESPACE: '$(CLUSTER_NAME)'
  steps:
  - script: sudo apt-get update && sudo apt-get install docker.io=18.06.1-0ubuntu1.2~16.04.1
    condition: and(succeeded(), eq(variables['CLUSTER'], 'minikube'))
    displayName: 'Downgrade Docker'
  - bash: ./.travis/fats.sh
    env:
      DOCKER_USERNAME: '$(DockerUsername)'
      DOCKER_PASSWORD: '$(DockerPassword)'
      GCLOUD_CLIENT_SECRET: '$(GcloudClientSecret)'
    displayName: 'Run FATS'
  - bash: ./.travis/fats-cleanup.sh
    env:
      DOCKER_USERNAME: '$(DockerUsername)'
      DOCKER_PASSWORD: '$(DockerPassword)'
      GCLOUD_CLIENT_SECRET: '$(GcloudClientSecret)'
    condition: always()
    displayName: 'Cleanup FATS'
